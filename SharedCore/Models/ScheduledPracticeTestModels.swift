import Foundation

// MARK: - Scheduled Practice Test Models

/// Status of a scheduled practice test
enum ScheduledTestStatus: String, Codable, CaseIterable {
    case scheduled = "Scheduled"
    case completed = "Completed"
    case missed = "Missed"
    case archived = "Archived"
    
    var displayText: String {
        rawValue
    }
}

enum PracticeTestScheduleKind: String, Codable, CaseIterable {
    case initial
    case followUp
}

/// A scheduled practice test with timing and metadata
struct ScheduledPracticeTest: Identifiable, Codable, Hashable {
    var id: UUID
    var courseId: UUID?
    var moduleIds: [UUID]
    var sourceAssignmentId: UUID?
    var taskId: UUID?
    var scheduleKind: PracticeTestScheduleKind
    var isAutoGenerated: Bool
    var questionCount: Int
    var timeLimitMinutes: Int
    var title: String
    var subject: String
    var unitName: String?
    var scheduledAt: Date
    var estimatedMinutes: Int?
    var difficulty: Int // 1-5
    var status: ScheduledTestStatus
    var createdAt: Date
    var updatedAt: Date
    
    init(
        id: UUID = UUID(),
        courseId: UUID? = nil,
        moduleIds: [UUID] = [],
        sourceAssignmentId: UUID? = nil,
        taskId: UUID? = nil,
        scheduleKind: PracticeTestScheduleKind = .initial,
        isAutoGenerated: Bool = false,
        questionCount: Int = 40,
        timeLimitMinutes: Int = 50,
        title: String,
        subject: String,
        unitName: String? = nil,
        scheduledAt: Date,
        estimatedMinutes: Int? = nil,
        difficulty: Int = 3,
        status: ScheduledTestStatus = .scheduled,
        createdAt: Date = Date(),
        updatedAt: Date = Date()
    ) {
        self.id = id
        self.courseId = courseId
        self.moduleIds = moduleIds
        self.sourceAssignmentId = sourceAssignmentId
        self.taskId = taskId
        self.scheduleKind = scheduleKind
        self.isAutoGenerated = isAutoGenerated
        self.questionCount = questionCount
        self.timeLimitMinutes = timeLimitMinutes
        self.title = title
        self.subject = subject
        self.unitName = unitName
        self.scheduledAt = scheduledAt
        self.estimatedMinutes = estimatedMinutes
        self.difficulty = max(1, min(5, difficulty))
        self.status = status
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case courseId
        case moduleIds
        case sourceAssignmentId
        case taskId
        case scheduleKind
        case isAutoGenerated
        case questionCount
        case timeLimitMinutes
        case title
        case subject
        case unitName
        case scheduledAt
        case estimatedMinutes
        case difficulty
        case status
        case createdAt
        case updatedAt
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(UUID.self, forKey: .id)
        courseId = try container.decodeIfPresent(UUID.self, forKey: .courseId)
        moduleIds = try container.decodeIfPresent([UUID].self, forKey: .moduleIds) ?? []
        sourceAssignmentId = try container.decodeIfPresent(UUID.self, forKey: .sourceAssignmentId)
        taskId = try container.decodeIfPresent(UUID.self, forKey: .taskId)
        scheduleKind = try container.decodeIfPresent(PracticeTestScheduleKind.self, forKey: .scheduleKind) ?? .initial
        isAutoGenerated = try container.decodeIfPresent(Bool.self, forKey: .isAutoGenerated) ?? false
        questionCount = try container.decodeIfPresent(Int.self, forKey: .questionCount) ?? 40
        timeLimitMinutes = try container.decodeIfPresent(Int.self, forKey: .timeLimitMinutes) ?? 50
        title = try container.decode(String.self, forKey: .title)
        subject = try container.decode(String.self, forKey: .subject)
        unitName = try container.decodeIfPresent(String.self, forKey: .unitName)
        scheduledAt = try container.decode(Date.self, forKey: .scheduledAt)
        estimatedMinutes = try container.decodeIfPresent(Int.self, forKey: .estimatedMinutes)
        difficulty = try container.decodeIfPresent(Int.self, forKey: .difficulty) ?? 3
        status = try container.decodeIfPresent(ScheduledTestStatus.self, forKey: .status) ?? .scheduled
        createdAt = try container.decodeIfPresent(Date.self, forKey: .createdAt) ?? Date()
        updatedAt = try container.decodeIfPresent(Date.self, forKey: .updatedAt) ?? Date()
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encodeIfPresent(courseId, forKey: .courseId)
        try container.encode(moduleIds, forKey: .moduleIds)
        try container.encodeIfPresent(sourceAssignmentId, forKey: .sourceAssignmentId)
        try container.encodeIfPresent(taskId, forKey: .taskId)
        try container.encode(scheduleKind, forKey: .scheduleKind)
        try container.encode(isAutoGenerated, forKey: .isAutoGenerated)
        try container.encode(questionCount, forKey: .questionCount)
        try container.encode(timeLimitMinutes, forKey: .timeLimitMinutes)
        try container.encode(title, forKey: .title)
        try container.encode(subject, forKey: .subject)
        try container.encodeIfPresent(unitName, forKey: .unitName)
        try container.encode(scheduledAt, forKey: .scheduledAt)
        try container.encodeIfPresent(estimatedMinutes, forKey: .estimatedMinutes)
        try container.encode(difficulty, forKey: .difficulty)
        try container.encode(status, forKey: .status)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(updatedAt, forKey: .updatedAt)
    }
    
    /// Returns computed status based on current time
    func computedStatus(hasCompletedAttempt: Bool) -> ScheduledTestStatus {
        if status == .archived {
            return .archived
        }
        if hasCompletedAttempt {
            return .completed
        }
        if scheduledAt < Date() && !hasCompletedAttempt {
            return .missed
        }
        return .scheduled
    }
}

/// A test attempt record
struct TestAttempt: Identifiable, Codable, Hashable {
    var id: UUID
    var scheduledTestID: UUID?
    var startedAt: Date
    var completedAt: Date?
    var score: Double?
    var outputReference: String? // JSON storage or file reference
    
    init(
        id: UUID = UUID(),
        scheduledTestID: UUID? = nil,
        startedAt: Date = Date(),
        completedAt: Date? = nil,
        score: Double? = nil,
        outputReference: String? = nil
    ) {
        self.id = id
        self.scheduledTestID = scheduledTestID
        self.startedAt = startedAt
        self.completedAt = completedAt
        self.score = score
        self.outputReference = outputReference
    }
    
    var isCompleted: Bool {
        completedAt != nil
    }
}

// MARK: - Week Range Helper

extension Calendar {
    /// Returns the start of the week (Monday) for a given date
    func startOfWeek(for date: Date) -> Date {
        var calendar = self
        calendar.firstWeekday = 2 // Monday
        let components = calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: date)
        return calendar.date(from: components) ?? date
    }
    
    /// Returns the end of the week (exclusive - start of next Monday)
    func endOfWeek(for date: Date) -> Date {
        let start = startOfWeek(for: date)
        return calendar.date(byAdding: .weekOfYear, value: 1, to: start) ?? start
    }
    
    /// Returns an array of dates for each day of the week (Mon-Sun)
    func daysOfWeek(for date: Date) -> [Date] {
        let start = startOfWeek(for: date)
        return (0..<7).compactMap { dayOffset in
            calendar.date(byAdding: .day, value: dayOffset, to: start)
        }
    }
}

private var calendar: Calendar {
    Calendar.current
}
