import Foundation

public final class SchedulingFallbackEngine: AIFallbackEngine {
    public init() {}

    public func canFallback(for port: AIPortID) -> Bool {
        switch port {
        case .generateStudyPlan, .schedulePlacement, .conflictResolution:
            return true
        default:
            return false
        }
    }

    public func executeFallback<P: AIPort>(
        _ portType: P.Type,
        input: P.Input,
        context: AIRequestContext
    ) async throws -> AIResult<P.Output> {
        switch portType {
        case is GenerateStudyPlanPort.Type:
            return try await fallbackGenerateStudyPlan(input: input, context: context) as! AIResult<P.Output>
        case is SchedulePlacementPort.Type:
            return try await fallbackSchedulePlacement(input: input, context: context) as! AIResult<P.Output>
        case is ConflictResolutionPort.Type:
            return try await fallbackConflictResolution(input: input, context: context) as! AIResult<P.Output>
        default:
            throw AIEngineError.capabilityUnavailable(port: P.id)
        }
    }

    private func fallbackGenerateStudyPlan(
        input: GenerateStudyPlanPort.Input,
        context: AIRequestContext
    ) async throws -> AIResult<GenerateStudyPlanPort.Output> {
        let sessions = PlannerEngine.generateSessions(for: input.assignment, settings: input.settings)
        let proposals = sessions.map {
            GenerateStudyPlanPort.SessionProposal(
                assignmentId: $0.assignmentId,
                title: $0.title,
                dueDate: $0.dueDate,
                category: $0.category,
                urgency: $0.importance,
                estimatedMinutes: $0.estimatedMinutes,
                isLockedToDueDate: $0.isLockedToDueDate,
                sessionIndex: $0.sessionIndex,
                sessionCount: $0.sessionCount
            )
        }

        let output = GenerateStudyPlanPort.Output(sessions: proposals)
        return AIResult(
            output: output,
            confidence: AIConfidence(0.6),
            provenance: .fallback(.fallbackHeuristic),
            diagnostic: AIDiagnostic(reasonCodes: ["fallback=plannerEngine"]),
            metadata: AIResultMetadata(
                inputHash: "fallback",
                computedAt: Date(),
                computedAtUptime: ProcessInfo.processInfo.systemUptime,
                featureStateVersion: 0
            )
        )
    }

    private func fallbackSchedulePlacement(
        input: SchedulePlacementPort.Input,
        context: AIRequestContext
    ) async throws -> AIResult<SchedulePlacementPort.Output> {
        let sessions = input.sessions.map { proposal in
            PlannerSession(
                assignmentId: proposal.assignmentId,
                sessionIndex: proposal.sessionIndex,
                sessionCount: proposal.sessionCount,
                title: proposal.title,
                dueDate: proposal.dueDate,
                category: proposal.category,
                importance: proposal.urgency,
                difficulty: proposal.urgency,
                estimatedMinutes: proposal.estimatedMinutes,
                isLockedToDueDate: proposal.isLockedToDueDate,
                scheduleIndex: 0
            )
        }

        let energyProfile = energyProfile(for: input.preference)
        let result = PlannerEngine.scheduleSessions(sessions, settings: StudyPlanSettings(), energyProfile: energyProfile)

        let scheduledBlocks = result.scheduled.map {
            SchedulePlacementPort.ScheduledBlock(
                assignmentId: $0.session.assignmentId,
                sessionIndex: $0.session.sessionIndex,
                start: $0.start,
                end: $0.end
            )
        }

        let overflow = result.overflow.map { session in
            GenerateStudyPlanPort.SessionProposal(
                assignmentId: session.assignmentId,
                title: session.title,
                dueDate: session.dueDate,
                category: session.category,
                urgency: session.importance,
                estimatedMinutes: session.estimatedMinutes,
                isLockedToDueDate: session.isLockedToDueDate,
                sessionIndex: session.sessionIndex,
                sessionCount: session.sessionCount
            )
        }

        let output = SchedulePlacementPort.Output(scheduled: scheduledBlocks, overflow: overflow)
        return AIResult(
            output: output,
            confidence: AIConfidence(0.55),
            provenance: .fallback(.fallbackHeuristic),
            diagnostic: AIDiagnostic(reasonCodes: ["fallback=plannerEngine"]),
            metadata: AIResultMetadata(
                inputHash: "fallback",
                computedAt: Date(),
                computedAtUptime: ProcessInfo.processInfo.systemUptime,
                featureStateVersion: 0
            )
        )
    }

    private func fallbackConflictResolution(
        input: ConflictResolutionPort.Input,
        context: AIRequestContext
    ) async throws -> AIResult<ConflictResolutionPort.Output> {
        let sessions = input.sessions.map { proposal in
            PlannerSession(
                assignmentId: proposal.assignmentId,
                sessionIndex: proposal.sessionIndex,
                sessionCount: proposal.sessionCount,
                title: proposal.title,
                dueDate: proposal.dueDate,
                category: proposal.category,
                importance: proposal.urgency,
                difficulty: proposal.urgency,
                estimatedMinutes: proposal.estimatedMinutes,
                isLockedToDueDate: proposal.isLockedToDueDate,
                scheduleIndex: 0
            )
        }

        let energyProfile = energyProfile(for: input.preference)
        let result = PlannerEngine.scheduleSessions(sessions, settings: StudyPlanSettings(), energyProfile: energyProfile)

        let scheduledBlocks = result.scheduled.map {
            SchedulePlacementPort.ScheduledBlock(
                assignmentId: $0.session.assignmentId,
                sessionIndex: $0.session.sessionIndex,
                start: $0.start,
                end: $0.end
            )
        }

        let overflow = result.overflow.map { session in
            GenerateStudyPlanPort.SessionProposal(
                assignmentId: session.assignmentId,
                title: session.title,
                dueDate: session.dueDate,
                category: session.category,
                urgency: session.importance,
                estimatedMinutes: session.estimatedMinutes,
                isLockedToDueDate: session.isLockedToDueDate,
                sessionIndex: session.sessionIndex,
                sessionCount: session.sessionCount
            )
        }

        let output = ConflictResolutionPort.Output(
            scheduled: scheduledBlocks,
            overflow: overflow,
            compressed: []
        )

        return AIResult(
            output: output,
            confidence: AIConfidence(0.5),
            provenance: .fallback(.fallbackHeuristic),
            diagnostic: AIDiagnostic(reasonCodes: ["fallback=plannerEngine"]),
            metadata: AIResultMetadata(
                inputHash: "fallback",
                computedAt: Date(),
                computedAtUptime: ProcessInfo.processInfo.systemUptime,
                featureStateVersion: 0
            )
        )
    }

    private func energyProfile(for preference: StudyTimePreference) -> [Int: Double] {
        switch preference {
        case .morning:
            return [
                7: 0.7, 8: 0.8, 9: 0.85, 10: 0.8, 11: 0.7,
                12: 0.5, 13: 0.45, 14: 0.4, 15: 0.35, 16: 0.3,
                17: 0.25, 18: 0.2, 19: 0.15, 20: 0.1
            ]
        case .afternoon:
            return [
                8: 0.4, 9: 0.5, 10: 0.6, 11: 0.7, 12: 0.8,
                13: 0.85, 14: 0.8, 15: 0.75, 16: 0.7,
                17: 0.6, 18: 0.5, 19: 0.4
            ]
        case .evening:
            return [
                9: 0.4, 10: 0.45, 11: 0.5, 12: 0.55, 13: 0.6,
                14: 0.65, 15: 0.7, 16: 0.75, 17: 0.8,
                18: 0.85, 19: 0.9, 20: 0.85, 21: 0.8
            ]
        case .balanced:
            return [
                9: 0.55, 10: 0.65, 11: 0.7, 12: 0.6,
                13: 0.5, 14: 0.55, 15: 0.65, 16: 0.7,
                17: 0.6, 18: 0.5, 19: 0.45, 20: 0.4
            ]
        }
    }
}
