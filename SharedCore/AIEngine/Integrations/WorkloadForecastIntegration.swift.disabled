import Foundation
import CoreData
import Combine

/// Integration B: Workload forecast (deterministic, provider-optional)
/// This integration provides instant workload forecasting using deterministic calculation,
/// with optional provider optimization that never blocks rendering.
@MainActor
public final class WorkloadForecastIntegration: ObservableObject {
    private let engine: AIEngine
    private let context: NSManagedObjectContext
    
    @Published public private(set) var currentForecast: IntegrationWorkloadForecast?
    @Published public private(set) var isOptimizing = false
    
    public init(engine: AIEngine, context: NSManagedObjectContext) {
        self.engine = engine
        self.context = context
    }
    
    /// Get immediate workload forecast (deterministic, never blocks)
    public func forecastWorkload(
        assignments: [AssignmentWorkloadData],
        startDate: Date,
        endDate: Date
    ) async -> IntegrationWorkloadForecast {
        // DETERMINISTIC: Instant calculation
        let forecast = calculateDeterministicForecast(
            assignments: assignments,
            startDate: startDate,
            endDate: endDate
        )
        
        currentForecast = forecast
        
        // Provider optimization runs in background (optional enhancement)
        Task.detached { [weak self] in
            await self?.optimizeInBackground(
                assignments: assignments,
                startDate: startDate,
                endDate: endDate,
                baseForecast: forecast
            )
        }
        
        return forecast
    }
    
    // MARK: - Private
    
    private func calculateDeterministicForecast(
        assignments: [AssignmentWorkloadData],
        startDate: Date,
        endDate: Date
    ) -> IntegrationWorkloadForecast {
        var weeklyLoads: [IntegrationWeekLoad] = []
        
        let calendar = Calendar.current
        var currentWeekStart = startDate
        
        while currentWeekStart < endDate {
            let weekEnd = calendar.date(byAdding: .day, value: 7, to: currentWeekStart) ?? endDate
            
            var totalMinutes = 0
            var categoryBreakdown: [String: Int] = [:]
            var peakDayMinutes = 0
            
            // Calculate workload for this week
            for assignment in assignments {
                guard let dueDate = assignment.dueDate,
                      dueDate >= currentWeekStart && dueDate < weekEnd else {
                    continue
                }
                
                totalMinutes += assignment.estimatedMinutes
                categoryBreakdown[assignment.category, default: 0] += assignment.estimatedMinutes
                
                // Track peak day
                let dayMinutes = calculateDayLoad(assignment, date: dueDate)
                peakDayMinutes = max(peakDayMinutes, dayMinutes)
            }
            
            let load = WeekLoad(
                weekStart: currentWeekStart,
                weekEnd: weekEnd,
                totalMinutes: totalMinutes,
                categoryBreakdown: categoryBreakdown,
                peakDayMinutes: peakDayMinutes,
                intensityLevel: calculateIntensity(totalMinutes: totalMinutes)
            )
            
            weeklyLoads.append(load)
            currentWeekStart = weekEnd
        }
        
        return WorkloadForecast(
            weeklyLoads: weeklyLoads,
            totalMinutes: weeklyLoads.reduce(0) { $0 + $1.totalMinutes },
            averageWeeklyMinutes: weeklyLoads.isEmpty ? 0 : weeklyLoads.reduce(0) { $0 + $1.totalMinutes } / weeklyLoads.count,
            peakWeekMinutes: weeklyLoads.map(\.totalMinutes).max() ?? 0,
            source: .deterministic,
            computedAt: Date(),
            confidence: 0.9
        )
    }
    
    private func calculateDayLoad(_ assignment: AssignmentWorkloadData, date: Date) -> Int {
        // Simple heuristic: distribute load over 3 days before due date
        let daysBeforeDue = 3
        return assignment.estimatedMinutes / daysBeforeDue
    }
    
    private func calculateIntensity(totalMinutes: Int) -> IntensityLevel {
        let hoursPerWeek = Double(totalMinutes) / 60.0
        
        switch hoursPerWeek {
        case 0..<10: return .light
        case 10..<20: return .moderate
        case 20..<30: return .heavy
        default: return .extreme
        }
    }
    
    private func optimizeInBackground(
        assignments: [AssignmentWorkloadData],
        startDate: Date,
        endDate: Date,
        baseForecast: IntegrationWorkloadForecast
    ) async {
        guard assignments.count > 5 else { return } // Only optimize for complex schedules
        
        await MainActor.run {
            isOptimizing = true
        }
        
        defer {
            Task { @MainActor in
                isOptimizing = false
            }
        }
        
        // Provider optimization with 300ms budget (never blocks UI)
        let input = WorkloadForecastInput(
            assignments: assignments.map { WorkloadAssignment(
                id: $0.id,
                dueDate: $0.dueDate ?? Date(),
                estimatedMinutes: $0.estimatedMinutes,
                category: $0.category,
                priority: $0.priority
            )},
            startDate: startDate,
            endDate: endDate,
            constraints: []
        )
        
        do {
            let result = try await engine.request(
                port: IntegrationWorkloadForecastPort(),
                input: input,
                context: AIContext(
                    timeBudget: 0.3,
                    privacyMode: .standard,
                    userID: "default"
                )
            )
            
            // Only update if optimization provides value
            if result.confidence > baseForecast.confidence {
                // Note: This would update visualization hints, not raw data
                print("Workload optimization complete, confidence improved: \(result.confidence)")
            }
        } catch {
            // Silent failure - deterministic forecast already rendered
            print("Workload optimization failed (expected): \(error)")
        }
    }
}

// MARK: - Supporting Types

public struct AssignmentWorkloadData {
    public let id: UUID
    public let dueDate: Date?
    public let estimatedMinutes: Int
    public let category: String
    public let priority: Int
    
    public init(id: UUID, dueDate: Date?, estimatedMinutes: Int, category: String, priority: Int) {
        self.id = id
        self.dueDate = dueDate
        self.estimatedMinutes = estimatedMinutes
        self.category = category
        self.priority = priority
    }
}

public struct IntegrationWorkloadForecast {
    public let weeklyLoads: [IntegrationWeekLoad]
    public let totalMinutes: Int
    public let averageWeeklyMinutes: Int
    public let peakWeekMinutes: Int
    public let source: ForecastSource
    public let computedAt: Date
    public let confidence: Double
    
    public enum ForecastSource {
        case deterministic
        case optimized
    }
}

public struct IntegrationWeekLoad {
    public let weekStart: Date
    public let weekEnd: Date
    public let totalMinutes: Int
    public let categoryBreakdown: [String: Int]
    public let peakDayMinutes: Int
    public let intensityLevel: IntensityLevel
}

public enum IntensityLevel: String {
    case light
    case moderate
    case heavy
    case extreme
    
    public var color: String {
        switch self {
        case .light: return "green"
        case .moderate: return "yellow"
        case .heavy: return "orange"
        case .extreme: return "red"
        }
    }
}
