import Foundation

public enum ConflictResolutionPort: AIPort {
    public static let id: AIPortID = .conflictResolution
    public static let name: String = "Conflict Resolution"
    public static let privacyRequirement: AIPrivacyLevel = .normal
    public static let mergePolicy: AIMergePolicy = .suggestOnly

    public struct Input: Codable, Sendable {
        public let sessions: [GenerateStudyPlanPort.SessionProposal]
        public let fixedEvents: [ScheduleFixedEvent]
        public let sleepWindow: SleepWindow
        public let maxDailyMinutes: Int
        public let preference: StudyTimePreference

        public init(
            sessions: [GenerateStudyPlanPort.SessionProposal],
            fixedEvents: [ScheduleFixedEvent] = [],
            sleepWindow: SleepWindow = SleepWindow(),
            maxDailyMinutes: Int = 360,
            preference: StudyTimePreference = .balanced
        ) {
            self.sessions = sessions
            self.fixedEvents = fixedEvents
            self.sleepWindow = sleepWindow
            self.maxDailyMinutes = maxDailyMinutes
            self.preference = preference
        }
    }

    public struct Output: Codable, Sendable {
        public let scheduled: [SchedulePlacementPort.ScheduledBlock]
        public let overflow: [GenerateStudyPlanPort.SessionProposal]
        public let compressed: [GenerateStudyPlanPort.SessionProposal]
    }

    public static func validate(input: Input) throws {
        guard !input.sessions.isEmpty else {
            throw AIEngineError.validationFailed(reason: "no sessions to resolve")
        }
    }

    public static func validate(output: Output) throws {
        guard output.scheduled.count + output.overflow.count + output.compressed.count > 0 else {
            throw AIEngineError.validationFailed(reason: "conflict output empty")
        }
    }
}
