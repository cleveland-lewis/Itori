import Foundation

public enum SchedulePlacementPort: AIPort {
    public static let id: AIPortID = .schedulePlacement
    public static let name: String = "Schedule Placement"
    public static let privacyRequirement: AIPrivacyLevel = .normal
    public static let mergePolicy: AIMergePolicy = .suggestOnly

    public struct Input: Codable, Sendable {
        public let sessions: [GenerateStudyPlanPort.SessionProposal]
        public let fixedEvents: [ScheduleFixedEvent]
        public let sleepWindow: SleepWindow
        public let maxDailyMinutes: Int
        public let preference: StudyTimePreference

        public init(
            sessions: [GenerateStudyPlanPort.SessionProposal],
            fixedEvents: [ScheduleFixedEvent] = [],
            sleepWindow: SleepWindow = SleepWindow(),
            maxDailyMinutes: Int = 360,
            preference: StudyTimePreference = .balanced
        ) {
            self.sessions = sessions
            self.fixedEvents = fixedEvents
            self.sleepWindow = sleepWindow
            self.maxDailyMinutes = maxDailyMinutes
            self.preference = preference
        }
    }

    public struct ScheduledBlock: Codable, Sendable, Hashable {
        public let assignmentId: UUID
        public let sessionIndex: Int
        public let start: Date
        public let end: Date
    }

    public struct Output: Codable, Sendable {
        public let scheduled: [ScheduledBlock]
        public let overflow: [GenerateStudyPlanPort.SessionProposal]
    }

    public static func validate(input: Input) throws {
        guard !input.sessions.isEmpty else {
            throw AIEngineError.validationFailed(reason: "no sessions to place")
        }
    }

    public static func validate(output: Output) throws {
        guard output.scheduled.count + output.overflow.count > 0 else {
            throw AIEngineError.validationFailed(reason: "placement output empty")
        }
    }
}
